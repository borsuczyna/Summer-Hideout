"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileResourceScripts = exports.compileResourceBundledScripts = exports.compileLuaLib = exports.compileAttachedFiles = exports.executeCompilerForAllResources = void 0;
const typescript_1 = require("typescript");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const typescript_to_lua_1 = require("typescript-to-lua");
const utils_1 = require("./utils");
const writer_1 = require("./meta/writer");
const validate_1 = require("./validate");
const utils_2 = require("typescript-to-lua/dist/utils");
const plugins_1 = require("./plugins");
const reportDiagnostic = (0, typescript_to_lua_1.createDiagnosticReporter)(false);
const writeData = function (fileName, data, writeByteOrderMark, onError) {
    data = data.replaceAll('local _G = {}', '-- local _G = {}');
    data = data.replaceAll('__BUILD_DATE', new Date().getTime() + '');

    const dirname = path.dirname(fileName);
    fs.mkdirSync(dirname, { recursive: true });
    fs.writeFile(path.join(fileName), data, function (err) {
        if (err !== null) {
            if (onError !== undefined) {
                onError(err.message);
            }
            else {
                console.log(err.message);
            }
        }
    });
};
function executeCompilerForAllResources(options, metaData) {
    const configCheckDiagnositcs = (0, validate_1.validateOptions)(options);
    (0, utils_1.showDiagnosticAndExit)(configCheckDiagnositcs, reportDiagnostic);
    const newOptions = Object.assign(Object.assign({}, options), { metaList: [...metaData] });
    for (const resourceMeta of metaData) {
        const data = (0, utils_1.getResourceData)(newOptions, resourceMeta);
        fs.mkdirSync(data.outDir, { recursive: true });
        let partialDiagnostics = compileLuaLib(newOptions, resourceMeta, data);
        (0, utils_1.showDiagnosticAndExit)(partialDiagnostics, reportDiagnostic);
        partialDiagnostics = compileAttachedFiles(newOptions, resourceMeta, data);
        (0, utils_1.showDiagnosticAndExit)(partialDiagnostics, reportDiagnostic);
        partialDiagnostics = compileResourceScripts(newOptions, resourceMeta, data);
        (0, utils_1.showDiagnosticAndExit)(partialDiagnostics, reportDiagnostic);
        partialDiagnostics = compileResourceBundledScripts(newOptions, resourceMeta, data);
        (0, utils_1.showDiagnosticAndExit)(partialDiagnostics, reportDiagnostic);
        if (newOptions.tstlVerbose) {
            console.log(`Generating meta.xml for "${data.verboseName}" resource`);
        }
        const { content: metaContent, diagnostics: metaDiagnostics } = (0, writer_1.generateResourceMetaContent)(resourceMeta, data);
        (0, utils_1.showDiagnosticAndExit)(metaDiagnostics, reportDiagnostic);
        const metaPath = path.join(data.outDir, 'meta.xml');
        fs.writeFileSync(metaPath, metaContent);
    }
}
exports.executeCompilerForAllResources = executeCompilerForAllResources;
/**
 * Copies all files into the destination directory
 */
function compileAttachedFiles(options, meta, data) {
    if (meta.files === undefined || meta.files.length === 0) {
        return [];
    }
    const files = meta.files.filter(file => file.doCompileCheck === undefined || file.doCompileCheck);
    const diagnosticResults = [];
    if (options.tstlVerbose) {
        console.log(`Copying files for "${data.verboseName}" resource...`);
    }
    for (const file of files) {
        const rootSrc = path.join(data.rootDir, file.src);
        const outSrc = path.join(data.outDir, file.src);
        const dirname = path.dirname(outSrc);
        try {
            fs.mkdirSync(dirname, { recursive: true });
            fs.copyFileSync(rootSrc, outSrc);
        }
        catch (e) {
            diagnosticResults.push((0, utils_1.simpleTsDiagnostic)(e.toString(), typescript_1.DiagnosticCategory.Error));
        }
    }
    return diagnosticResults;
}
exports.compileAttachedFiles = compileAttachedFiles;
/**
 * Compiles lualib_bundle.lua
 */
function compileLuaLib(options, meta, data) {
    if (meta.scripts === undefined || meta.scripts.length === 0) {
        console.log(`No scripts defined in the meta file.\n` +
            `Skipped compiling lualib_bundle.lua for "${data.verboseName}" resource...`);
        return [];
    }
    let diagnosticResults = [];
    const newOptions = Object.assign(Object.assign({}, (0, utils_1.extendOptions)(options, meta, data)), { rootDir: path.dirname((0, utils_1.getEmptyTsFilePath)()), outDir: data.outDir, luaLibImport: typescript_to_lua_1.LuaLibImportKind.Always });
    if (options.tstlVerbose) {
        console.log(`Compiling lualib_bundle.lua for "${data.verboseName}" resource...`);
    }
    const { diagnostics } = (0, typescript_to_lua_1.transpileFiles)([(0, utils_1.getEmptyTsFilePath)()], newOptions, function (fileName, dataWrite, writeByteOrderMark, onError, sourceFiles) {
        if (!fileName.endsWith('lualib_bundle.lua')) {
            return;
        }
        return writeData(fileName, dataWrite, writeByteOrderMark, onError, sourceFiles);
    });
    diagnosticResults = [...diagnosticResults, ...diagnostics];
    return diagnosticResults;
}
exports.compileLuaLib = compileLuaLib;
/**
 * Converts scripts, defined in `scripts` object into the result files
 */
function compileResourceBundledScripts(options, meta, data) {
    var _a;
    const scripts = (0, utils_1.getScriptsFromMeta)(meta);
    let diagnosticResults = [];
    for (const key of Object.keys(scripts)) {
        const newOptions = Object.assign(Object.assign({}, (0, utils_1.extendOptions)(options, meta, data)), { luaLibImport: typescript_to_lua_1.LuaLibImportKind.Require, luaPlugins: [...((_a = options.luaPlugins) !== null && _a !== void 0 ? _a : []), ...(0, plugins_1.getPlugins)(true)] });
        const scriptList = scripts[key];
        if (newOptions.tstlVerbose) {
            console.log(`Compiling ${key} bundled scripts for "${data.verboseName}" resource...`);
        }
        const scriptsToBuild = scriptList
            .filter(script => script.bundled)
            .map(script => ({
            in: (0, utils_2.normalizeSlashes)(path.join(data.rootDir, script.src)),
            out: (0, utils_2.normalizeSlashes)(path.join(data.outDir, script.src.replace(/\.ts$/, '.lua'))),
        }));
        for (const script of scriptsToBuild) {
            const scriptOptions = Object.assign(Object.assign({}, newOptions), { luaBundle: script.out, luaBundleEntry: script.in });
            const result = (0, typescript_to_lua_1.transpileFiles)([script.in], scriptOptions, writeData);
            diagnosticResults = [...diagnosticResults, ...result.diagnostics];
        }
    }
    return diagnosticResults;
}
exports.compileResourceBundledScripts = compileResourceBundledScripts;
/**
 * Converts scripts, defined in `scripts` object into the result files
 */
function compileResourceScripts(options, meta, data) {
    var _a;
    const scripts = (0, utils_1.getScriptsFromMeta)(meta);
    let diagnosticResults = [];
    for (const key of Object.keys(scripts)) {
        const newOptions = Object.assign(Object.assign({}, (0, utils_1.extendOptions)(options, meta, data)), { luaLibImport: typescript_to_lua_1.LuaLibImportKind.None, luaPlugins: [...((_a = options.luaPlugins) !== null && _a !== void 0 ? _a : []), ...(0, plugins_1.getPlugins)(false)] });
        const scriptList = scripts[key];
        if (newOptions.tstlVerbose) {
            console.log(`Compiling ${key} scripts for "${data.verboseName}" resource...`);
        }
        const scriptsToBuild = scriptList
            .filter(script => !script.bundled)
            .map(script => (0, utils_2.normalizeSlashes)(path.join(data.rootDir, script.src)));
        const scriptsToBuildSet = new Set();
        scriptsToBuild.forEach(value => scriptsToBuildSet.add(path.resolve(value)));
        const emittedScripts = new Set();
        const result = (0, typescript_to_lua_1.transpileFiles)(scriptsToBuild, newOptions, function (fileName, content, writeByteOrderMark, onError, sourceFiles) {
            if(fileName.endsWith('.map') || fileName.endsWith('.d.ts')) return;
            if (sourceFiles !== undefined) {
                const anotherResource = sourceFiles.filter(file => !file.fileName.startsWith(data.rootDir)).length !== 0;
                if (anotherResource) {
                    console.log(`File ${fileName} is provided from an another resource.` +
                        ` Skipping emit...`);
                    return;
                }
                else {
                    for (const file of sourceFiles) {
                        emittedScripts.add(path.resolve(file.fileName));
                    }
                }
            }
            writeData(fileName, content, writeByteOrderMark, onError, sourceFiles);
        });
        for (const scriptPath of emittedScripts) {
            if (scriptsToBuildSet.has(scriptPath)) {
                continue;
            }
            diagnosticResults.push((0, utils_1.simpleTsDiagnostic)(`File '${scriptPath}' is used, ` +
                `but not specified in mtasa-meta.yml ` +
                `for "${data.verboseName}" resource`, typescript_1.DiagnosticCategory.Error));
        }
        diagnosticResults = [...diagnosticResults, ...result.diagnostics];
    }
    return diagnosticResults;
}
exports.compileResourceScripts = compileResourceScripts;
//# sourceMappingURL=compile.js.map