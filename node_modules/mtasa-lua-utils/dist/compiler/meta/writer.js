"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateResourceMetaContent = exports.generateResourceMetaObject = exports.LUA_LIB_FILENAME = void 0;
const xml_js_1 = require("xml-js");
const utils_1 = require("../utils");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const typescript_1 = require("typescript");
exports.LUA_LIB_FILENAME = 'lualib_bundle.lua';
function genComment(message) {
    return {
        type: 'comment',
        comment: message,
    };
}
function objectValuesToString(object) {
    const newObject = {};
    for (const entry of Object.entries(object)) {
        newObject[entry[0]] = entry[1].toString();
    }
    return newObject;
}
function genScriptTag(script, hideAdditionalProps) {
    const processedScript = Object.assign(Object.assign({}, script), { src: script.src.replace(/\.ts$/, '.lua') });
    if (hideAdditionalProps) {
        delete processedScript.bundled;
    }
    return {
        type: 'element',
        name: 'script',
        attributes: objectValuesToString(processedScript),
    };
}
function genMapTag(map) {
    return {
        type: 'element',
        name: 'map',
        attributes: objectValuesToString(map),
    };
}
function genFileTag(file, hideAdditionalProps) {
    const processedFile = Object.assign({}, file);
    if (hideAdditionalProps) {
        delete processedFile.doCompileCheck;
    }
    return {
        type: 'element',
        name: 'file',
        attributes: objectValuesToString(file),
    };
}
function genIncludeTag(include) {
    return {
        type: 'element',
        name: 'include',
        attributes: objectValuesToString(include),
    };
}
function genConfigTag(config) {
    return {
        type: 'element',
        name: 'config',
        attributes: objectValuesToString(config),
    };
}
function genExportTag(exportData) {
    return {
        type: 'element',
        name: 'export',
        attributes: objectValuesToString(exportData),
    };
}
function genHtmlTag(html) {
    return {
        type: 'element',
        name: 'html',
        attributes: objectValuesToString(html),
    };
}
function genSettingTag(setting) {
    return {
        type: 'element',
        name: 'setting',
        attributes: objectValuesToString(setting),
    };
}
function getMinMtaVersionTag(data) {
    return {
        type: 'element',
        name: 'min_mta_version',
        attributes: objectValuesToString(data),
    };
}
function genAclRequestTag(data) {
    return {
        type: 'element',
        name: 'aclrequest',
        attributes: objectValuesToString(data),
    };
}
function genCustomTag(tagData) {
    let innerTags = [];
    if (typeof tagData.value === 'string') {
        innerTags = [
            {
                type: 'text',
                text: tagData.value,
            },
        ];
    }
    else if (tagData.value !== undefined) {
        innerTags = tagData.value.map(inner => genCustomTag(inner));
    }
    return {
        type: 'element',
        name: tagData.name,
        attributes: tagData.properties,
        elements: innerTags,
    };
}
function generateResourceMetaObject(meta, data) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    const emptyComment = {
        type: 'comment',
        comment: '',
    };
    const luaLibExists = fs_1.default.existsSync(path_1.default.join(data.outDir, exports.LUA_LIB_FILENAME));
    const hideAdditionalProps = !((_a = meta.compilerConfig.outMetaAdditionalProperties) !== null && _a !== void 0 ? _a : true);
    const commentWrapper = (...args) => {
        if (meta.compilerConfig.outMetaComments ||
            meta.compilerConfig.outMetaComments == undefined) {
            return args;
        }
        return [];
    };
    return {
        elements: [
            {
                type: 'element',
                name: 'meta',
                elements: [
                    ...commentWrapper(genComment('This file has been generated by' +
                        ' https://mtasa-typescript.github.io/'), genComment('DO NOT EDIT THIS FILE MANUALLY. ' +
                        'ALL CHANGES WILL BE LOST'), emptyComment, genComment('Resource information')),
                    {
                        type: 'element',
                        name: 'info',
                        attributes: Object.assign(Object.assign({}, meta.info), { gamemodes: (_b = meta.info.gamemodes) === null || _b === void 0 ? void 0 : _b.join(',') }),
                    },
                    ...commentWrapper(emptyComment, genComment('Library scripts')),
                    luaLibExists
                        ? genScriptTag({
                            type: 'shared',
                            src: exports.LUA_LIB_FILENAME,
                            cache: false,
                        }, hideAdditionalProps)
                        : {},
                    ...commentWrapper(emptyComment, genComment('Scripts')),
                    ...((_d = (_c = meta.scripts) === null || _c === void 0 ? void 0 : _c.map(data => genScriptTag(data, hideAdditionalProps))) !== null && _d !== void 0 ? _d : []),
                    ...commentWrapper(emptyComment, genComment('Maps')),
                    ...((_f = (_e = meta.maps) === null || _e === void 0 ? void 0 : _e.map(data => genMapTag(data))) !== null && _f !== void 0 ? _f : []),
                    ...commentWrapper(emptyComment, genComment('Files')),
                    ...((_h = (_g = meta.files) === null || _g === void 0 ? void 0 : _g.map(data => genFileTag(data, hideAdditionalProps))) !== null && _h !== void 0 ? _h : []),
                    ...commentWrapper(emptyComment, genComment('Includes')),
                    ...((_k = (_j = meta.includes) === null || _j === void 0 ? void 0 : _j.map(data => genIncludeTag(data))) !== null && _k !== void 0 ? _k : []),
                    ...commentWrapper(emptyComment, genComment('Configs')),
                    ...((_m = (_l = meta.configs) === null || _l === void 0 ? void 0 : _l.map(data => genConfigTag(data))) !== null && _m !== void 0 ? _m : []),
                    ...commentWrapper(emptyComment, genComment('Exports')),
                    ...((_p = (_o = meta.exports) === null || _o === void 0 ? void 0 : _o.map(data => genExportTag(data))) !== null && _p !== void 0 ? _p : []),
                    ...commentWrapper(emptyComment, genComment('HTMLs')),
                    ...((_r = (_q = meta.htmls) === null || _q === void 0 ? void 0 : _q.map(data => genHtmlTag(data))) !== null && _r !== void 0 ? _r : []),
                    ...commentWrapper(emptyComment, genComment('Settings')),
                    {
                        type: 'element',
                        name: 'settings',
                        elements: (_t = (_s = meta.settings) === null || _s === void 0 ? void 0 : _s.map(data => genSettingTag(data))) !== null && _t !== void 0 ? _t : [],
                    },
                    ...commentWrapper(emptyComment, genComment('Minimum version required')),
                    meta.minMtaVersion
                        ? getMinMtaVersionTag(meta.minMtaVersion)
                        : {},
                    ...commentWrapper(emptyComment, genComment('ACL Requests')),
                    {
                        type: 'element',
                        name: 'aclrequest',
                        elements: (_v = (_u = meta.aclRequests) === null || _u === void 0 ? void 0 : _u.map(data => genAclRequestTag(data))) !== null && _v !== void 0 ? _v : [],
                    },
                    ...commentWrapper(emptyComment, genComment('Sync map element data (or not)')),
                    meta.syncMapElementData
                        ? {
                            type: 'element',
                            name: 'sync_map_element_data',
                            elements: [
                                {
                                    type: 'text',
                                    text: meta.syncMapElementData,
                                },
                            ],
                        }
                        : {},
                    ...commentWrapper(emptyComment, genComment('OOP')),
                    {
                        type: 'element',
                        name: 'oop',
                        elements: [
                            {
                                type: 'text',
                                text: 'true',
                            },
                        ],
                    },
                    ...commentWrapper(emptyComment, genComment('Download Priority')),
                    meta.downloadPriorityGroup
                        ? {
                            type: 'element',
                            name: 'download_priority_group',
                            elements: [
                                {
                                    type: 'text',
                                    text: 'true',
                                },
                            ],
                        }
                        : {},
                    ...commentWrapper(emptyComment, genComment('Custom Tags')),
                    ...((_x = (_w = meta.additionalTags) === null || _w === void 0 ? void 0 : _w.map(data => genCustomTag(data))) !== null && _x !== void 0 ? _x : []),
                ],
            },
        ],
    };
}
exports.generateResourceMetaObject = generateResourceMetaObject;
function generateResourceMetaContent(meta, data) {
    var _a, _b;
    const jsMeta = generateResourceMetaObject(meta, data);
    if (jsMeta.elements === undefined || jsMeta.elements.length === 0) {
        return {
            content: '<meta><info name="Generation error happened" /></meta>',
            diagnostics: [
                (0, utils_1.simpleTsDiagnostic)('Internal error: meta.xml contains no objects', typescript_1.DiagnosticCategory.Error),
            ],
        };
    }
    jsMeta.elements[0].elements = (_b = (_a = jsMeta.elements) === null || _a === void 0 ? void 0 : _a[0].elements) === null || _b === void 0 ? void 0 : _b.filter(element => Object.keys(element).length > 0);
    return {
        content: (0, xml_js_1.js2xml)(jsMeta, {
            compact: false,
            spaces: 4,
        }),
        diagnostics: [],
    };
}
exports.generateResourceMetaContent = generateResourceMetaContent;
//# sourceMappingURL=writer.js.map