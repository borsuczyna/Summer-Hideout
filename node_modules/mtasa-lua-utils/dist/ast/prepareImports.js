"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts = __importStar(require("typescript"));
const typescript_to_lua_1 = require("typescript-to-lua");
const symbols_1 = require("typescript-to-lua/dist/transformation/utils/symbols");
const utils_1 = require("./utils");
const path = __importStar(require("path"));
const utils_2 = require("../compiler/utils");
// TODO: make configurable
const importSpecifiersMapToGlobalTable = [
    {
        namePattern: /^mtasa$/,
        modulePattern: /^mtasa-lua-types\/(client|server)$/,
    },
];
function resolveImportsFromAnotherModules(node, context) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (node.moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {
        return [];
    }
    if (!(0, utils_1.isLocalImport)(node, context)) {
        return [];
    }
    const moduleFullPath = path.resolve((0, utils_1.getImportNodeModuleFile)(node, context).fileName);
    const options = context.options;
    const targetResources = (_a = options.metaList) === null || _a === void 0 ? void 0 : _a.filter(meta => {
        var _a;
        return moduleFullPath.startsWith(path.join((_a = options.originalRootDir) !== null && _a !== void 0 ? _a : '', meta.compilerConfig.srcDir));
    });
    if (!targetResources || targetResources.length === 0) {
        context.diagnostics.push((0, utils_2.simpleTsDiagnostic)(`Do not import something not from the resource` +
            `\n(file: ${context.sourceFile.fileName})` +
            `\n(import: ${moduleFullPath})`, ts.DiagnosticCategory.Warning));
        return [];
    }
    const targetResource = targetResources[0];
    const isSameResource = targetResource.compilerConfig.srcDir ===
        ((_b = options.resourceSpecific) === null || _b === void 0 ? void 0 : _b.compilerConfig.srcDir);
    if (isSameResource) {
        return [];
    }
    // Issue #155
    // TODO: issue #156
    const originResourceDir = path.join((_c = options.originalRootDir) !== null && _c !== void 0 ? _c : '', (_e = (_d = options.resourceSpecific) === null || _d === void 0 ? void 0 : _d.compilerConfig.srcDir) !== null && _e !== void 0 ? _e : '');
    const filePath = path.resolve(context.sourceFile.fileName);
    if (!filePath.startsWith(originResourceDir)) {
        return [];
        // Ok that's another resource. Do not try to compile it.
    }
    const typeChecker = context.program.getTypeChecker();
    if (((_f = node.importClause) === null || _f === void 0 ? void 0 : _f.namedBindings) === undefined) {
        return context.superTransformStatements(node);
    }
    if (node.importClause.namedBindings.kind === ts.SyntaxKind.NamespaceImport) {
        return context.superTransformStatements(node);
    }
    const namedBindings = node.importClause.namedBindings;
    const importedSymbols = namedBindings.elements
        .map(value => typeChecker.getTypeAtLocation(value).symbol)
        .filter(value => value !== undefined);
    const result = [];
    for (const symbol of importedSymbols) {
        if (!symbol.declarations || symbol.declarations.length === 0) {
            continue;
        }
        const declaration = symbol.valueDeclaration;
        if (!declaration) {
            continue;
        }
        if (ts.isInterfaceDeclaration(declaration) ||
            ts.isEnumDeclaration(declaration)) {
            continue;
        }
        if (ts.isFunctionDeclaration(declaration)) {
            const currentSide = (0, utils_1.getFileSide)(context.sourceFile.fileName, context);
            const declarationName = declaration.name;
            if (!declarationName) {
                continue;
            }
            const availableExports = (_g = targetResource.exports) === null || _g === void 0 ? void 0 : _g.filter(value => {
                var _a;
                return value.type === currentSide &&
                    value.function === ((_a = declaration.name) === null || _a === void 0 ? void 0 : _a.text);
            });
            if (!availableExports || availableExports.length === 0) {
                context.diagnostics.push((0, utils_2.simpleTsDiagnostic)(`You cannot import function from another resource, ` +
                    `if it is not listed in the exports section` +
                    `\n(file: ${context.sourceFile.fileName})` +
                    `\n(import: ${moduleFullPath})`, ts.DiagnosticCategory.Error));
            }
            else {
                const resourceName = (0, utils_1.getResourceDirectoryName)(targetResource);
                result.push((0, typescript_to_lua_1.createVariableDeclarationStatement)((0, typescript_to_lua_1.createIdentifier)(declarationName.text, declarationName, (0, symbols_1.getIdentifierSymbolId)(context, declarationName)), (0, typescript_to_lua_1.createIdentifier)(`function(...) return exports["${resourceName}"]:${declarationName.text}(...) end`), declarationName));
            }
        }
        if (ts.isClassDeclaration(declaration) ||
            ts.isVariableDeclaration(declaration)) {
            context.diagnostics.push((0, utils_2.simpleTsDiagnostic)(`You cannot import variable or class from another resource` +
                `\n(file: ${context.sourceFile.fileName})` +
                `\n(import: ${moduleFullPath})`, ts.DiagnosticCategory.Error));
        }
    }
    return result;
}
const prepareGlobalImports = function (node, context) {
    const importClause = node.importClause;
    if ((importClause === null || importClause === void 0 ? void 0 : importClause.namedBindings) === undefined) {
        return context.superTransformStatements(node);
    }
    if (importClause.namedBindings.kind === ts.SyntaxKind.NamespaceImport) {
        return context.superTransformStatements(node);
    }
    const namedImports = importClause.namedBindings;
    if (node.moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {
        return [];
    }
    const moduleSpecifier = node.moduleSpecifier;
    const module = moduleSpecifier.text;
    const specifiers = importSpecifiersMapToGlobalTable.filter(value => module.match(value.modulePattern));
    if (specifiers.length === 0) {
        return [
            ...resolveImportsFromAnotherModules(node, context),
            ...namedImports.elements
                .filter(value => !!value.propertyName)
                .map(value => {
                var _a, _b;
                return (0, typescript_to_lua_1.createVariableDeclarationStatement)((0, typescript_to_lua_1.createIdentifier)(value.name.text, value.name, (0, symbols_1.getIdentifierSymbolId)(context, value.name)), (0, typescript_to_lua_1.createIdentifier)((_b = (_a = value.propertyName) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : 'nil'), value);
            }),
        ];
    }
    const specifier = specifiers[0];
    return namedImports.elements
        .filter(value => {
        var _a;
        return ((_a = value.propertyName) !== null && _a !== void 0 ? _a : value.name).text.match(specifier.namePattern);
    })
        .map(value => (0, typescript_to_lua_1.createVariableDeclarationStatement)((0, typescript_to_lua_1.createIdentifier)(value.name.text, value.name, (0, symbols_1.getIdentifierSymbolId)(context, value.name)), (0, typescript_to_lua_1.createIdentifier)((0, utils_1.getGlobalsTableName)()), value));
};
exports.default = {
    visitors: {
        [ts.SyntaxKind.ImportDeclaration]: prepareGlobalImports,
    },
};
//# sourceMappingURL=prepareImports.js.map